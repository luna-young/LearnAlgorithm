## 선택 정렬 / Selection Sort
 - 메모리가 동작하는 방법
 ![]( https://www.log2base2.com/images/c/computer-memory-address.png)
   - **컴퓨터의 동작 방식은 서랍에 물건을 보관하는 것과 같다**. 하나의 서랍에는 하나의 물건을 넣어둘 수 있다. 컴퓨터는 엄청나게 많은 서랍을 가지고 있고 각각의 서랍에는 주소가 붙어있는 꼴이다. 우리가 메모리에 무언가를 저장해야 할 때마다 **컴퓨터에게 공간을 요청하면 컴퓨터는 무언가를 저장할 수 있는 주소를 알려**준다. 만약 **여러 개의 원소를 저장해야 한다면 배열과 리스트라는 두 가지 방법 중 하나를 사용해야 한다**.  
   
 - [자료 구조] 배열과 연결 리스트
   - **여러 개**의 할일 목록을 메모리에 저장해야 하는 경우를 생각해보자. 

     - 배열(Array)
      ![](https://codeforwin.org/wp-content/uploads/2015/07/array-and-array-index-representation.png)
     할일들을 메모리에 **차례대로 붙여서** 저장한다. 세 개의 목록을 저장한 후 네 번째 할일을 추가하여야 하는 상황은 친구들과 영화를 보러 극장에 가서 앉을 자리를 찾는 것과 비슷하다. 극장에서 친 구 한 명을 더 만나게 되었는데 이미 우리 옆 자리에 사람이 앉아 있다면 그 친구와 같이 앉을 수 없다. 이런 경우에는 컴퓨터에게 4개의 자리가 있는 메모리 공간을 요청한 후, 4개의 할일을 모두 그 자리로 옮겨야 한다. 또 다른 친구가 오면 이런 일은 반복된다. 즉, **배열에 새 원소를 추가하는 일은 쉽지 않다**. 
       - 좌석을 **미리 예약**하는 것은 어떨까? 현재 할일은 3개밖에 없어도 10개의 목록을 저장할 수 있는 메모리를 요청하는 것이다. 이런 경우 할일 목록을 10개까지는 순조롭게 추가할 수 있지만 몇 가지 **단점**이 있다. 
         - 만약 추가할 일이 생기지 않는다면 메모리를 쓸데없이 낭비한 셈이 된다.
         - 만약에 목록의 크기가 10개보다 커진다면 어차피 자리를 옮겨야 한다.
    
    
    - 연결 리스트(Linked List)
     ![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQe0z6-d7-ZN47LmZ5yqrhsshbsMxGZ6Pa7O0ZR5UWUi4vMEWLACQ)
      원소를 메모리의 어느 곳에나 둘 수 있다. **각 원소에는 목록의 다음 원소에 대한 주소가 저장**되어 있다. 즉, 여러 가지 임의의 메모리 주소들이 하나의 목록으로 연결되어 있다. 마치 보물찾기와 비슷하다. 첫 번째 주소로 가면 그 곳에 다음 보물의 주소가 적혀있는 식이다. 연결 리스트를 사용하면 **원소를 추가하는 일이 쉽다**. 메모리의 아무 곳에나 원소를 넣고, 그 주소를 바로 앞의 원소에 저장해두기만 하면 된다. 연결 리스트를 사용하면 원소를 옮길 일이 없다. 
    
    
     - 비교     
     ![](https://cdn-images-1.medium.com/max/1600/1*sBUu3B4LnXxmKV1P5FVbWg.png)
       - **모든 원소의 값**을 한 번에 읽어야 한다면 연결 리스트**가 좋지만, **특정한 원소만 알고 싶다면 연결 리스트는 최악**이다. 원소가 이웃하고 있지 않아서 몇 번째 원소가 어디에 있는지 바로 계산할 수 없기 때문이다. 
       - 배열에서는 모든 원소의 주소를 다 알고 있다. 원소의 위치를 **인덱스(index)** 라고 한다. 
       ![](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/array-2.png)
       - **원소의 배열이나 리스트의 중앙에 삽입**해야 한다면 리스트가 낫다. **이전 원소가 무엇을 가리키는지 바꾸기만** 하면 되기 때문이다. 배열에서는 다음에 오는 모든 원소의 위치를 바꾸어야 하며, 공간이 부족할 경우 모든 원소를 새로운 장소로 복사해야 한다. 
       - **원소를 삭제**해야 하는 경우에도 **이전 원소가 가리키는 위치만 바꾸면 되기 때문에 리스트가 낫다**. 
       - 경우에 따라 다르지만, 배열에서는 **임의의 원소에 접근하는 것이 가능하기 때문**에 배열을 쓴느 경우가 더 많다. 
       - 반면 **연결 리스트에서는 원소를 처음부터 하나씩 읽는 순차 접근(sequential access)밖에** 할 수 없다. 
       - 배열의 읽기 속도가 빠른 이유는 **배열에서는 임의 접근(random access)이 가능**하기 때문이다. 즉, 임의 접근을 필요로 하는 경우가 많기 때문에 배열이 더 많이 사용되는 것이다. 
 
 
 - [알고리즘] 선택 정렬(Selection Sort)

   - 무작위로 정렬된 숫자들을 작은 수부터 차례대로 정리해야 한다면? 한 가지 방법은 리스트의 모든 항목을 살펴보고 가장 작은 수부터 새로운 리스트에 기록하고 이를 반복하는 것이다. 이때 **모든 원소를 한 번씩 건드려야 하므로 O(n)의 시간**이 걸린다. 또한 가장 작은 숫자를 찾기 위해서는 **모든 항목을 점검**해야 한다. 즉 O(n) 실행 시간이 걸리는 연산을 n번 해야 하므로 결과적으로 **O(n * n) = O(n제곱) 시간**이 걸린다. 
     - 이 연산을 할 때 실제로 점검해야 할 항목의 수는 줄어들지만 실행시간은 O(n제곱)인 이유는 빅오 표기법의 상수항과 관련이 있다. 매번 실행할 때마다 n개의 항목을 모두 점검할 필요가 없다는 점은 맞다. 처음에는 n개, 다음에는 n-1, n-2, ..2, 1로 줄어들어 평균적으로는 1/2 * n개의 항목을 점검하므로 실행시간은 O(n*1/2*n)이 된다. 하지만 **빅오 표기법에서는 1/2와 같은 상수항은 무시**하므로 O(n*n), 즉 O(n제곱)이라고 쓰는 것이다. 
   ![](https://cdn-images-1.medium.com/max/1200/1*S-wdMkkaX3Gr4bQrbqu_1Q.jpeg)
