## 해시 테이블 / Hash Table
 
 - 해시함수(Hash Function)
    - ![](http://www.newscu.net/news/photo/201706/1050_627_1343.png) 
    - 알파벳 순서로 정렬된 장부에서 물품의 가격을 찾는다면, 단순 탐색은 O(n) 시간, 이진 탐색은 O(log n)의 시간이 소요된다.
    - 하지만 손님이 밀려든다면 아무리 이진 탐색이라고 해도 출납업무의 속도를 향상하는 데 한계가 있다.
    - 이때 필요한 것은 모든 물건의 이름과 가격을 외우고 있는 동료이다. 이런 동료가 있다면 장부를 찾아볼 필요 없이 동료에게 물어보기만 하면 되기 때문이다. 
    - 이 동료는 모든 항목에 대해 O(1) 시간 만에 가격을 알려준다. 이진 탐색보다도 빠른 것이다. 
    - 해시 함수는 **문자열string을 받아서 숫자를 반환**한다. 기술 용어로 바꾸어 말하면,  **문자열에 대해 숫자를 할당mapping**한다. 
    - 해시 함수는 다음과 같은 요건을 갖추어야 한다.
        - **같은 문자열에 대해서는 같은 값을 반환하는 일관성**이 있어야 한다.
        - 다른 단어가 들어가면 다른 숫자가 나와야 한다. 가장 좋은 경우는 서로 다른 단어에 대해 모두 서로 다른 숫자를 반환하는 것이다.
    - 해시 함수에 상품의 가격 정보를 저장하면 해시 함수는 가격이 저장된 위치를 정확하게 알려준다. 즉, **탐색을 할 필요가 전혀 없다**는 것이다.
    

 
- 해시 테이블(Hash Table)
    - ![](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Hashing/pix/hashing1.bmp) 
    - **해시 함수와 배열을 합치면 해시 테이블hash table**이라는 자료구조가 된다. **해시 테이블은 해시 함수라는 추가적인 논리구조를 가진다**. 
    - 배열과 리스트는 직접 메모리를 할당하지만, 해시 테이블은 해시 함수를 사용해서 어디에 원소를 저장할지 결정한다.  
    - 해시 테이블은 키key와 값value을 가진다. 
    - ![](https://study.cs50.net/slideshows/1WyRdHGA7wYMYg078wXpv9qAjrELJBokRFRKGnVbnI7Q/img/0.png)
    - 해시 테이블의 장점
        - 어떤 것과 다른 것 사이의 관계를 모형화할 수 있다.
        - 중복을 막을 수 있다.
        - 서버에게 작업을 시키지 않고 자료를 캐싱할 수 있다. 
    - 해시 테이블 사용 사례: 전화번호부, DNS 확인(웹 주소에 IP 할당), 중복된 항목 방지, 캐싱 등 
  
 - 충돌 (Collision)
    - ![](http://www.qlikfix.com/wp-content/uploads/2014/03/Collision.png) 
    - 두 개의 키가 같은 공간에 할당되는 것 
    - 충돌을 해결하는 방법은 여러 가지가 있지만, 가장 간단한 것은 같은 공간에 여러 개의 키를 연결 리스트로 만들어 넣는 것이다. 하지만 만약 해시 테이블의 거의 모든 항목들이 그 연결 리스트에 있다면 이것은 그냥 모든 항목을 연결 리스트에 넣은 것이나 다름없는 셈이다. 결국 해시 테이블은 느려지게 된다.
        - 해시 함수는 정말 중요하다. 이상적으로 해시 함수는 키를 해시 테이블 전체에 고르게 할당해야 한다.
        - 만약 연결 리스트가 길어지면 해시 테이블의 속도도 느려진다. 하지만 좋은 해시 함수가 있다면 그런 일은 발생하지 않는다. 
    - 좋은 해시 함수는 충돌을 최소화한다. 

 - 성능
    - ![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRluYkBVjGSmp_uF3TQcGbyHby6CP8fNwuTAdjOf-lohMLb-WQm)
    - **평균적인 경우에 해시 테이블은 모든 항목에 대해 O(1) 시간이 걸린다. O(1)은 상수 시간constant time**이라고 불린다. 상수 시간은 순간적이라는 뜻이 아니라, **해시 테이블의 크기에 상관없이 항상 똑같은 시간이 걸린다는 뜻**이다. 
    - 해시 테이블이 하나의 항목을 가지든 10억 개의 항목을 가지든 해시 테이블에서 무언가를 찾는 데 걸리는 시간은 항상 똑같다. 
        - 이는 배열과 같다. 배열이 아무리 크든 작든 상관없이 원소 하나를 꺼내는 데 걸리는 시간은 동일하기 때문이다.  
    - **평균적인 경우에 해시 테이블은 아주 빠르지만, 최악의 경우에 해시 테이블은 모든 항목에 대해 O(n) 시간, 즉 선형시간이 걸린다**. 
    - 최악의 경우가 발생하지 않게 하려면 충돌을 피해야 한다. 이를 위해서는 다음과 같은 것이 필요하다.
        - 낮은 사용률(load factor)
            - 사용률: 해시 테이블에 있는 항목의 수/ 해시 테이블에 있는 공간의 수  
            - 사용률이 1보다 크다는 것은 배열에 공간의 수보다 항목의 수가 많다는 뜻으로, 사용률이 커지기 시작하면 해시 테이블의 공간을 추가해야 한다. 이것을 리사이징(resizing)이라고 한다. 보통 사용률이 0.7보다 커지면 리사이징한다. 
        - 좋은 해시 함수: 배열에 값을 골고루 분포시키는 함수
            - 나쁜 해시 함수는 값들이 뭉쳐져 있어서 충돌이 자주 발생한다. 
 
