## 너비 우선 탐색 / Breadth First Search
 
 - 활용
    - 너비 우선 탐색을 사용하면 두 항목 간의 최단 경로를 찾을 수 있다. 
    - 예를 들어 다음과 같은 것을 만드는 데 너비 우선 탐색을 사용할 수 있다. 
      - 체커 게임에서 가장 적은 수로 승리할 수 있는 방법을 계산하는 인공지능
      - 맞춤법 검사기(실제 단어에서 가장 적은 개수의 글자를 고쳐서 올바른 단어를 만드는 방법을 찾음)
      - 자신의 네트워크에서 가장 가까운 의사 찾기
    - ![](http://monthly.chosun.com/upload/1705/1705_532_5.jpg)
    - [‘총알배송’은 어떻게 가능할까? - 최적계획 찾기](https://pub.chosun.com/client/news/viw.asp?cate=C03&nNewsNumb=20170524671&nidx=24672)
    ```sh
     세계일주 하는 사람들은 대개 저렴한 비용으로 가장 효율적으로 이동할 수 있는 경로를 찾아 여행 계획을 세운다. 이때 반드시 지켜야 하는 조건은 아래 두 가지이다.
     1) 서울을 출발하여 서울로 다시 돌아올 것 2) 모든 나라를 방문하되 동일 나라는 한 번만 방문할 것. 이번에도 역시 예를 들어 생각해 보자.
   [예] 서울을 출발하여, 홍콩, 뉴욕, LA, 파리, 런던, 두바이를 방문하고 다시 서울로 돌아오는 여행을 계획 중이다. 이용할 수 있는 항공 노선표를 고려했을 때 어떤 경로로 여행을 해야 가장 효율적일까?
     ```
    - 우리가 샌프란시스코에 있고, 트윈 픽스Twin Peaks에서 금문교Golden Gate Bridge까지 가고 싶다고 가정하자. 버스로 가지만 최대한 적게 가고 싶다. 이런 종류의 문제를 **최단 경로 문제shortest-path problem**이라고 한다. 최단 경로, 즉 가장 짧은 것을 찾아야 한다. 목표는 친구 집까지 가는 최단 경로일 수도 있고, 체스 게임에서 체크 메이트를 만드는 데 필요한 최소한의 수일 수도 있다. 이렇게 **최단 경로 문제를 푸는 알고리즘을 너비 우선 탐색**이라고 한다. 
      - 트윈 픽스에서 금문교까지 가는 방법을 찾으려면 다음과 같은 절차가 필요하다.
         1) 문제를 그래프로 모형화 한다. 
         2) 너비 우선 탐색으로 문제를 푼다. 
    
 - 그래프(Graph)
    - ![](http://mathworld.wolfram.com/images/eps-gif/GraphNodesEdges_1000.gif) 
    - 그래프란 **연결의 집합을 모형화한 것**이다.
    - 그래프는 정점node와 간선edge로 이루어진다. 정점은 여러 개의 다른 정점과 바로 이어질 수 있다. 이렇게 바로 이어진 정점을 이웃neighbor라고 한다. 
    - **그래프는 항목들이 서로 어떻게 연결되어 있는지를 모형화하는 방법이다**.
    - 트리는 거꾸로 가는 간선이 없는 특별한 종류의 그래프이다. 트리는 그래프의 특별한 경우이므로, 트리는 항상 그래프이지만 그래프는 트리가 아닐 수도 있다. 

 - 너비 우선 탐색
    - ![](https://upload.wikimedia.org/wikipedia/commons/4/46/Animated_BFS.gif)
    - **너비 우선 탐색은 그래프를 대상으로 하는 탐색 알고리즘**이다. 
    - 너비 우선 탐색은 다음과 같은 두 종료의 질문에 대답하는 데 도움이 된다.
        1) 정점 A에서 정점 B로 가는 경로가 존재하는가?
        2) 정점 A에서 정점 B로 가는 최단 경로는 무엇인가?
    - 당신이 망고 농장의 주인이고, 페이스북에서 망고를 팔아줄 수 있는 판매상을 찾고 있다고 가정해보자. 이를 위해, 
        - 우선 페이스북의 친구 목록을 살펴봐야 한다. 찾아볼 친구 목록을 만든 뒤 그 목록에서 각각의 사람이 망고 판상인지 아닌지 확인한다. 
        - 만약 친구 중 망고 판매상이 없다면 친구의 친구를 찾아볼 차례다. 
        - 최종적인 목표는 당신의 네트워크에서 망고 판매상을 찾는 것이다. 그러니까 만약 앨리스가 망고 판매상이 아니면 앨리스의 친구도 목록에 올려야 한다. 
        - 결과적으로 그녀의 친구, 그녀 친구의 친구, 이런 식으로 **망고 판매상에 도달할 때까지 전체 네트워크를 탐색하는 것이다. 이러한 알고리즘이 바로 너비 우선 탐색**이다. 
        - 정리하자면 
            1) 정점 A에서 정점 B로 가는 경로가 존재하는가? (당신의 네트워크에 망고 판매상이 있는가?)
            2) 정점 A에서 정점 B로 가는 최단 경로는 무엇인가? (누가 가장 가까운 망고 판매상인가?)
        - 첫 번째 질문에 대답하는 방법이 전체 네트워크를 탐색하는 것이라면 이제는 가장 가까운 망고 판매상을 찾을 차례다. 즉 페이스북 친구가 1촌이고 친구의 친구가 2촌이라면 1촌 관계인 망고 판매상이 없을 경우에만 2촌 관계를 탐색해야 한다. **너비 우선 탐색이 진행될수록 탐색 범위는 출발점에서 멀어진다. 그러니까, 2촌 관계를 확인하기 이전에 1촌 관계부터 확인해야**한다. 
    - 너비 우선 탐색은 A에서 B로 가는 경로가 있는지 알려준다.
    - 만약 경로가 존재한다면 최단 경로도 찾아준다. 
    - 장점
       - 출발노드에서 목표노드까지의 최단 길이 경로를 보장한다.
    - 단점
       - 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 하게 된다.
       - 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝난다.
       - 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못한다. 
    
  - 큐(Queue)
    - ![](https://res.cloudinary.com/practicaldev/image/fetch/s--Is8YL7Ba--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://cl.ly/d84e17fec485/Image%25202018-09-13%2520at%252012.22.09%2520PM.png) 
    - **너비 우선 탐색은 단순히 A에서 B로 가는 경로를 찾는 것이 아니라 최단 경로를 찾는 데 쓰인다**. 
    - **이 방법은 목록에 추가한 순서대로 사람을 찾을 때만 가능하다. 또한 당신은 목록에 더해진 순서대로 사람을 탐색해야** 한다. 이를 위한 자료구조가 큐queue 또는 대기열이라 불리는 자료구조이다. 
    - 큐는 **큐 안의 원소에 임의로 접근할 수 없다**는 점에서 스택과 비교된다.
    - 큐에는 삽입enqueue와 제거dequeue라고 하는 두 가지 연산이 있다.
    - 큐를 사용하면 목록에 먼저 추가된 사람들을 꺼내어 먼저 탐색한다. 
    - 따라서 큐를 선입 선출FIFO(First In First Out) 자료구조라고도 한다. 반대로 스택은 후입 선출LIFO(Last In First Out) 자료구조이다. 

- 그래프 구현하기
    - 그래프는 몇 개의 정점으로 이루어져 있고 각각의 정점은 이웃하는 정점과 연결된다. 즉, **그래프는 여러 개의 정점과 간선이 모여있는 것**이다. 
    - ![](https://slideplayer.com/slide/8478459/26/images/10/The+Principle+Of+Distributed+Hash+Tables.jpg)
    - 해시 테이블을 사용하면 키에 값을 할당할 수 있는데, 이 경우에는 어떤 정점에 이웃하는 정점을 할당한다. 
        - 해시 테이블은 순서를 가지지 않기 때문에 키/값 쌍을 어떤 순서로 추가하든 상관없다. 
    - ![](http://www.ritambhara.in/wp-content/uploads/2017/06/Screen-Shot-2017-06-10-at-7.17.01-PM.png)
        - 방향 그래프directed graph: 관계에는 방향성이 있다. 위 그림 (B)에서 E는 D의 이웃이지만 D는 E의 이웃이 아니다. 
        - 무방향 그래프undirected graph: 무방향 그래프(A)에서는 화살표, 즉 방향성을 가지지 않기 때문에 이어진 두 정점은 서로 이웃이 된다. **무방향 그래프는 둘 간의 상호 관계**를 나타낸다.

- 알고리즘의 구현
    - ![](https://images.tutorialedge.net/uploads/breadth-first-search.png?v=123) 
    - 망고 판매상을 찾는 목표로 돌아가자. 앨리스에게는 밥이라는 친구가 있고 앨리스와 밥 모두 페기라는 친구가 있다고 가정하자. 그래서 페기는 앨리스의 친구로 한 번, 밥의 친구로 한 번씩 큐에 총 두 번 들어가게 된다. 하지만 당신은 페기가 망고 판매상인지 한 번만 확인하면 된다. 따라서 어떤 사람을 확인하고 나면 그 사람이 다시 탐색되지 않도록 표시해야 한다. 그렇지 않으면 무한 반복에 빠질 수 있기 때문이다. 
    - 따라서 **사람을 확인하기 전에 이미 확인한 사람인지 확실히 해두어야 하고, 이를 위해서는 이미 확인한 사람의 명단을 가지고 있어야 한다**. 
    - 실행 시간
        - 망고 판매상을 찾기 위해 네트워크 전체를 탐색한다는 것은 **모든 정점을 따라서 움직인다**는 뜻이다. 즉 실행 시간은 최소한 O(간선의 개수)가 된다.
        - 또한 탐색할 사람을 저장하는 큐도 있어야 한다. 큐에 사람을 추가하는 데는 상수 시간, 즉 O(1)이 걸린다. 모든 사람에 대해 이것을 적용하면 총 O(사람의 수) 시간이 걸린다. 
        - 따라서 너비 우선 탐색은 O(사람의 수 + 간선의 수)가 되고, 보통 O(V+E)라고 표기한다. 
            - V는 정점의 수, E는 간선의 수다. 

- 참고
  - 너비 우선 탐색은 트리나 그래프를 방문 또는 탐색하는 방법이다. 탐색 방법은 다음과 같다.
   1. 루트에서 시작한다.
   2. 자식 노드들을 [1]에 저장한다.
   3. [1]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [2]에 저장한다.
   4. [2]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [3]에 저장한다.
   5. 위의 과정을 반복한다.
   6. 모든 노드를 방문하면 탐색을 마친다.
  - ![](https://ww.namu.la/s/1fe9246903b78fae07577b243a0b22791e02cb39640d5cbaae10d9849343b4ea6f162a9a677a5892fbf7819abd4ef7221ebd3608849cfb66793411fb5e643951217cf582e199c32b3a86b8c3316bbeac3988ee37d8eaeb90b980d3c7c498a498)
    ```sh
    DFS와의 가장 큰 차이로, 
    여러 갈래 중 무한한 길이를 가지는 경로가 존재하고 탐색 목표가 다른 경로에 존재하는 경우 
    DFS로 탐색할 시에는 무한한 길이의 경로에서 영원히 종료하지 못하지만, 
    BFS의 경우는 모든 경로를 동시에 진행하기 때문에 탐색이 가능하다는 특징이 있다.

    또한 BFS는 한 갈림길에서 연결되는 모든 길을 한번씩 탐색하기 때문에 
    가중치가 없는 그래프에서는 시작점에서 끝점까지의 최단경로를 알아낼 수 있다. 
    위 움짤의 BFS의 탐색 순서를 살펴볼 때 1번 노드에서 직접 연결된 곳은 2번, 3번, 4번 노드이다. 
    여기 있는 모든 경로의 길이를 1이라고 한다면, 
    1번에서 2번, 3번, 4번 노드까지의 길이는 1이다. 
    똑같은 방법으로 모든 노드 사이의 거리를 구할 수 있다. 
    따라서 시작점과 끝점이 주어진다면 주어진 그래프(네트위크)에서 최단 경로를 알아낼 수 있다.
    ```
  
- 관련 자료 및 출처
    - [위키백과](https://ko.wikipedia.org/wiki/너비_우선_탐색)
    - ![](https://docs.microsoft.com/en-us/sql/relational-databases/graphs/media/sql-graph-architecture.png?view=sql-server-2017) 
    - [컴맹분들도 이해할 수 있는 용어설명! DFS와 BFS](https://www.youtube.com/watch?v=-wsYtm0x3nw)
    - [‘총알배송’은 어떻게 가능할까? - 최적계획 찾기](https://pub.chosun.com/client/news/viw.asp?cate=C03&nNewsNumb=20170524671&nidx=24672)
    - [나무위키](https://namu.wiki/w/BFS)

